{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Braico.Me","text":""},{"location":"#things-i-can-do","title":"Things I Can Do","text":"<ul> <li> <p><p> Write code in Python</p></p> <p>As Python's official documentation says, it's a powerful and easy to learn programming language.</p> <p> Python official documentation</p> </li> <li> <p><p> Use Git and GitHub like a pro</p></p> <p>Using Git and GitHub is cool because they enable collaboration, version control, and seamless project management.</p> <p> Visit my account</p> </li> <li> <p><p> Write docs as code</p></p> <p>Let's focus our attention on creating good quality content and let the right tools let the hard work for us.</p> <p> Read more about this philosophy</p> </li> <li> <p><p> Work with Linux</p></p> <p>Linux ecosystem grants the freedom of open source, the opportunity for innovation, and the excitement of continuous learning.</p> <p> Get to know Pop!_Os</p> </li> <li> <p><p> Open source contributions</p></p> <p>Open source fosters collaborative innovation, and has the potential to enhance public administration efficiency.</p> <p> Read more about it</p> </li> <li> <p><p> Use Power Automate</p></p> <p>Power Automate empowers non-programmers to automate tasks, boost productivity, and innovate effortlessly.</p> <p> Get to know the Automatiza.MG project</p> </li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/python-pathlib/","title":"Python pathlib","text":"<p>Working with files and interacting with the file system are common tasks for Python developers. That\u2019s where pathlib comes in. Let's understand how it works with the help of the Python's pathlib Module: Taming the File System post.</p> <ul> <li> <p>The pathlib module is part of Python\u2019s standard library.</p> </li> <li> <p>The pathlib\u2019s Path class works the same way on different operating systems.</p> </li> <li> <p>One motivation behind pathlib is to represent the file system with dedicated objects instead of strings<sup>1</sup>.</p> </li> <li> <p>Traditionally, Python has represented file paths using regular strings. However, paths are more than plain strings.</p> </li> <li> <p>As an initial example of pathlib usage, the following code block moves files into a subfolder:</p> <pre><code>from pathlib import Path # (1)! # (2)!\n\nfor file_path in Path.cwd().glob(\"*.txt\"):\n    new_path = Path(\"archive\") / file_path.name\n    file_path.replace(new_path)\n</code></pre> <ol> <li> Because you\u2019ll mainly be working with the Path class of pathlib, importing it as <code>from pathlib import Path</code> saves you a few keystrokes in your code. This way, you can work with Path directly, rather than importing pathlib as a module and referring to <code>pathlib.Path</code>.</li> </ol> </li> </ul>"},{"location":"blog/python-pathlib/#using-path-methods","title":"Using Path Methods","text":"<ul> <li> <p>Once you\u2019ve imported Path, you can make use of existing methods to get the current working directory (<code>cwd</code>) (1), or your user\u2019s home directory.</p> </li> <li> <p>To get your current working directory, you can use <code>.cwd()</code>:</p> </li> </ul> <ol> <li> The current working directory is the directory in the file system that the current process is operating in. Using the home directory as a starting point, you can specify paths that\u2019ll work on different machines, independent of any specific usernames.</li> </ol> LinuxmacOSWindows <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path.cwd() # (1)!\nPosixPath('/home/gabrielbdornas/Desktop/codei')\n</code></pre> <ol> <li> Using the home directory as a starting point, you can specify paths that\u2019ll work independent of any specific usernames.</li> </ol> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path.cwd() # (1)!\nPosixPath('/Users/gabrielbdornas/Desktop/codei')\n</code></pre> <ol> <li> Using the home directory as a starting point, you can specify paths that\u2019ll work independent of any specific usernames.</li> </ol> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path.cwd() # (1)!\nWindowsPath('C:/Users/gabrielbdornas/Desktop/codei')\n</code></pre> <ol> <li> Using the home directory as a starting point, you can specify paths that\u2019ll work independent of any specific usernames.</li> </ol> <ul> <li>To get your home directory, you can use <code>.home()</code>:</li> </ul> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path.home() # (1)!\nPosixPath('/home/gabrielbdornas/')\n</code></pre> <ol> <li> With <code>Path.cwd()</code>and <code>Path.home()</code>, you can conveniently get a starting point for your Python scripts. In cases where you need to spell paths out or reference a subdirectory structure, you can instantiate Path with a string.</li> </ol>"},{"location":"blog/python-pathlib/#passing-in-a-string","title":"Passing in a String","text":"<ul> <li>Instead of starting in your user\u2019s home directory or your current working directory, you can point to a directory or file directly by passing its string representation into Path:</li> </ul> LinuxWindows <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path(\"/home/gabrielbdornas/Desktop/codei/file.txt\")\nPosixPath('/home/gabrielbdornas/Desktop/codei/file.txt')\n</code></pre> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path(r\"C:\\Users\\gabrielbdornas\\codei\\file.txt\")\nWindowsPath('C:/Users/gabrielbdornas/Desktop/codei/file.txt') # (1)!\n</code></pre> <ol> <li> On Windows, the path separator is a backslash (). However, in many contexts, the backslash is also used as an escape character to represent non-printable characters. To avoid problems, use raw string literals to represent Windows paths like <code>r\"C:\\Users\"</code>.</li> </ol> The <code>__file__</code> attribute <p>An idiomatic way of working with the current module\u2019s location as the path is using <code>__file__</code>:</p> <pre><code># hello.py\n\nfrom pathlib import Path\n\nprint(f\"You can find me here: {Path(__file__).parent}!\") # (1)!\n</code></pre> <ol> <li> The <code>__file__</code> attribute contains the path to the file that Python is currently importing or executing. You can pass in <code>__file__</code> to Path when you need to work with the path to the module itself. For example, maybe you want to get the parent directory with <code>.parent</code>.</li> </ol>"},{"location":"blog/python-pathlib/#joining-paths","title":"Joining Paths","text":"<ul> <li>A third way to construct a path is to join the parts of the path using the special forward slash operator (<code>/</code>):</li> </ul> <pre><code>from pathlib import Path\n\nfor file_path in Path.cwd().glob(\"*.txt\"):\n    new_path = Path(\"archive\") / file_path.name # (1)!\n    file_path.rename(new_path)\n</code></pre> <ol> <li> The forward slash operator can join several paths or a mix of paths and strings as long as you include one Path object. You use a forward slash regardless of your platform\u2019s actual path separator.</li> </ol> The <code>.joinpath()</code> method <ul> <li>If you don\u2019t like the special slash notation, then you can do the same operation with the <code>.joinpath()</code> method:</li> </ul> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path.home().joinpath(\"python\", \"scripts\", \"test.py\")\nPosixPath('/home/gabrielbdornas/python/scripts/test.py')\n</code></pre>"},{"location":"blog/python-pathlib/#file-system-operations-with-paths","title":"File System Operations With Paths","text":"<ul> <li> <p>A file or directory path consists of different parts. When you use pathlib, these parts are conveniently available as properties. Basic examples include:</p> <ul> <li><code>.name</code>: The filename without any directory</li> <li><code>.stem</code>: The filename without the file extension</li> <li><code>.suffix</code>: The file extension</li> <li><code>.anchor</code>: The part of the path before the directories</li> <li><code>.parent</code>: The directory containing the file, or the parent directory if the path is a directory</li> </ul> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; path = Path(__file__)\n&gt;&gt;&gt; path\nPosixPath(\"/home/gabrielbdornas/codei/test.md\")\n\n&gt;&gt;&gt; path.name\n'test.md'\n\n&gt;&gt;&gt; path.stem\n'test'\n\n&gt;&gt;&gt; path.suffix\n'.md'\n\n&gt;&gt;&gt; path.anchor\n'/'\n\n&gt;&gt;&gt; path.parent # (1)!\nPosixPath(\"/home/gabrielbdornas/codei\")\n\n&gt;&gt;&gt; path.parent.parent\nPosixPath('/home/gabrielbdornas')\n</code></pre> <ol> <li> Note that <code>.parent</code> returns a new Path object, whereas the other properties return strings. This means, for instance, that you can chain <code>.parent</code> in the last example or even combine it with the slash operator to create completely new paths.</li> </ol> </li> </ul>"},{"location":"blog/python-pathlib/#reading-and-writing-files","title":"Reading and Writing Files","text":"<ul> <li>Consider that you want to print all the items on a shopping list that you wrote down in a Markdown file. The content of shopping_list.md looks like this:</li> </ul> <pre><code>&lt;!-- shopping_list.md --&gt;\n\n# Shopping List\n\n## Fruit\n\n* Banana\n* Apple\n* Peach\n\n## Candy\n\n* Chocolate\n* Nougat Bits\n</code></pre> <ul> <li> <p>With pathlib, you can use <code>open()</code> directly on Path objects.</p> </li> <li> <p>A first draft of your script that finds all the items in <code>shopping_list.md</code> and prints them may look like this:</p> <pre><code># read_shopping_list.py\n\nfrom pathlib import Path\n\npath = Path.cwd() / \"shopping_list.md\"\nwith path.open(mode=\"r\", encoding=\"utf-8\") as md_file: # (1)!\n    content = md_file.read()\n    groceries = [line for line in content.splitlines() if line.startswith(\"*\")]\nprint(\"\\n\".join(groceries))\n</code></pre> <ol> <li> In fact, <code>Path.open()</code> is calling the built-in <code>open()</code> function behind the scenes. That\u2019s why you can use parameters like mode and encoding with <code>Path.open()</code>.</li> </ol> </li> <li> <p>On top of that, pathlib offers some convenient methods to read and write files:</p> <ul> <li><code>.read_text()</code> opens the path in text mode and returns the contents as a string.</li> <li><code>.read_bytes()</code> opens the path in binary mode and returns the contents as a byte string.</li> <li><code>.write_text()</code> opens the path and writes string data to it<sup>2</sup><sup>3</sup>.</li> <li><code>.write_bytes()</code> opens the path in binary mode and writes data to it<sup>2</sup><sup>3</sup>.</li> </ul> </li> <li> <p>Therefore, you can update <code>read_shopping_list.py</code> using <code>.read_text()</code>:</p> <pre><code># read_shopping_list.py\n\nfrom pathlib import Path\n\npath = Path.cwd() / \"shopping_list.md\" # (1)!\ncontent = path.read_text(encoding=\"utf-8\")\ngroceries = [line for line in content.splitlines() if line.startswith(\"*\")]\nprint(\"\\n\".join(groceries))\n</code></pre> <ol> <li> You can also specify paths directly as in <code>Path(\"shopping_list.md\")</code>, in which case they\u2019re interpreted relative to the current working directory.</li> </ol> </li> <li> <p>If you want to create a plain shopping list that only contains the groceries, then you can use <code>.write_text()</code> in a similar fashion:</p> <pre><code># write_plain_shoppinglist.py\n\nfrom pathlib import Path\n\ncontent = Path(\"shopping_list.md\").read_text(encoding=\"utf-8\")\ngroceries = [line for line in content.splitlines() if line.startswith(\"*\")]\n\nPath(\"plain_list.md\").write_text(\"\\n\".join(groceries), encoding=\"utf-8\")\n</code></pre> </li> </ul>"},{"location":"blog/python-pathlib/#renaming-files","title":"Renaming Files","text":"<ul> <li> <p>When you want to rename files, you can use <code>.with_stem()</code>, <code>.with_suffix()</code>, or <code>.with_name()</code>. They return the original path but with the filename, the file extension, or both replaced. You can use all of them in combination with <code>.replace()</code>, example:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; txt_path = Path('/home/gabrielbdornas/codei/hello.txt')\n&gt;&gt;&gt; txt_path\nPosixPath('/home/gabrielbdornas/codei/hello.txt')\n\n&gt;&gt;&gt; md_path = txt_path.with_suffix('.md') # (1)!\nPosixPath('/home/gabrielbdornas/codei/hello.md')\n\n&gt;&gt;&gt; txt_path.replace(md_path) # (2)!\n</code></pre> <ol> <li> <p> Using <code>.with_suffix()</code> returns a new path.</p> </li> <li> <p> To actually rename the file, you use <code>.replace()</code>. This moves <code>txt_path</code> to <code>md_path</code> and renames it when saving.</p> </li> </ol> </li> <li> <p>If you want to change the complete filename, including the extension, then you can use <code>.with_name()</code>:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; txt_path = Path('/home/gabrielbdornas/codei/hello.txt')\n&gt;&gt;&gt; txt_path\nPosixPath('/home/gabrielbdornas/codei/hello.txt')\n\n&gt;&gt;&gt; md_path = txt_path.with_name('goodbye.md')\nPosixPath('/home/gabrielbdornas/codei/goodbye.md')\n\n&gt;&gt;&gt; txt_path.replace(md_path) # (1)!\n</code></pre> <ol> <li> It renames <code>hello.txt</code> to <code>goodbye.md</code>.</li> </ol> </li> </ul>"},{"location":"blog/python-pathlib/#copying-files","title":"Copying Files","text":"<ul> <li> <p>Surprisingly, Path doesn\u2019t have a method to copy files. But with the knowledge that you\u2019ve gained about pathlib so far, you can create the same functionality with a few lines of code:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; source = Path('shopping_list.md')\n&gt;&gt;&gt; destination = source.with_stem('shopping_list_02') # (1)!\n&gt;&gt;&gt; destination.write_bytes(source.read_bytes()) # (2)!\n</code></pre> <ol> <li> You\u2019re using <code>.with_stem()</code> to create the new filename without changing the extension.</li> <li> The actual copying takes place here, where you use <code>.read_bytes()</code> to read the content of source and then write this content to destination using <code>.write_bytes()</code>.</li> </ol> </li> </ul>"},{"location":"blog/python-pathlib/#moving-and-deleting-files","title":"Moving and Deleting Files","text":"<ul> <li> <p>Through pathlib, you also have access to basic file system\u2013level operations like moving, updating, and even deleting files. For the most part, these methods don\u2019t give a warning or wait for confirmation before getting rid of information or files. So, be careful when using these methods<sup>3</sup>.</p> </li> <li> <p>To move a file, you can use <code>.replace()</code><sup>2</sup>. To avoid possibly overwriting the destination path, you can test whether the destination exists before replacing:</p> <pre><code>from pathlib import Path\nsource = Path('hello.py')\ndestination = Path('goodbye.py')\n\nif not destination.exists():\n  source.replace(destination)\n</code></pre> </li> <li> <p>However, this does leave the door open for a possible race condition. Another process may add a file at the destination path between the execution of the if statement and the <code>.replace()</code> method. If that\u2019s a concern, then a safer way is to open the destination path for exclusive creation then explicitly copy the source data and delete the source file afterward:</p> <pre><code>from pathlib import Path\n\nsource = Path('hello.py')\ndestination = Path('goodbye.py')\n\ntry:\n  with destination.open(mode='xb') as file:\n    file.write(source.read_bytes())\nexcept FileExistsError:\n    print(f'File {destination} existis already') # (1)!\nelse:\n    source.unlink() # (2)!\n</code></pre> <ol> <li> <p> If destination already exists, it catches a <code>FileExistsError</code> and prints a warning message.</p> </li> <li> <p> To perform a move, you need to delete source with <code>.unlink()</code> after the copy is done. Using <code>else</code> ensures that the source file isn\u2019t deleted if the copying fails.</p> </li> </ol> </li> </ul>"},{"location":"blog/python-pathlib/#creating-empty-files","title":"Creating Empty Files","text":"<ul> <li> <p>To create an empty file with pathlib, you can use <code>.touch()</code>. This method is intended to update a file\u2019s modification time, but you can use its side effect to create a new file:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; filename = Path('hello.py')\n&gt;&gt;&gt; filename.exists()\nFalse\n\n&gt;&gt;&gt; filename.touch()\n&gt;&gt;&gt; filename.exists() # (1)!\nTrue\n\n&gt;&gt;&gt; filename.touch() # (2)!\n</code></pre> <ol> <li> <p> You use <code>.exists()</code> both to verify that the file didn\u2019t exist before and then to check that it was successfully created.</p> </li> <li> <p> If you use <code>.touch()</code> again, then it updates the file\u2019s modification time. If you don\u2019t want to modify files accidentally, then you can use the <code>exist_ok</code> parameter and set it to False as in <code>filename.touch(exist_ok=False)</code>.</p> </li> </ol> </li> </ul>"},{"location":"blog/python-pathlib/#python-pathlib-examples","title":"Python pathlib Examples","text":""},{"location":"blog/python-pathlib/#counting-files","title":"Counting Files","text":"<ul> <li> <p>With pathlib, you can conveniently use the <code>.iterdir()</code> method, which iterates over all the files in the given directory:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; counter(path.suffix for path in Path.cwd().iterdir()) # (1)!\nCounter({'.md': 2, '.txt': 4, '.pdf': 2, '.py': 1})\n</code></pre> <ol> <li> You can create more flexible file listings with the methods <code>.glob()</code> and <code>.rglob()</code>. For example, <code>Path.cwd().glob(\"*.txt\")</code> returns all the files with a <code>.txt</code> suffix in the current directory.</li> </ol> </li> </ul> <ol> <li> <p>In general, you should try to use Path objects as much as possible in your code to take advantage of their benefits, but converting them to strings can be necessary in certain contexts. Some libraries and APIs still expect you to pass file paths as strings, so you may need to convert a Path object to a string before passing it to certain functions. You'll see that, on Windows, although you enter paths with backslashes, pathlib represents them with the forward slash (/) as the path separator. This representation is named POSIX style. POSIX stands for Portable Operating System Interface, which is a standard for maintaining the compability between operating systems.\u00a0\u21a9</p> </li> <li> <p>When using these methods, Python overwrites any existing files on the same path without giving you any notice. That means you could erase all your hard work with a single keystroke! As always, when you write files with Python, you should be cautious of what your code is doing. The same is true when you\u2019re renaming files.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>A good way to protect yoursef of this kind of troble is using version control system while writing your codes.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"blog/category/python/","title":"Python","text":""},{"location":"blog/category/pythons-standard-library/","title":"Python\u2019s standard library","text":""}]}