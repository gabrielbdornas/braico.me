{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Braico.Me","text":""},{"location":"#things-i-can-do","title":"Things I Can Do","text":"<ul> <li> <p> Write code in Python</p> <p>As Python's official documentation says, it's a powerful and easy to learn programming language.</p> <p> Python official documentation</p> </li> <li> <p></p><p> Use Git and GitHub like a pro</p> <p>Using Git and GitHub is cool because they enable collaboration, version control, and seamless project management.</p> <p> Visit my account</p> </li> <li> <p></p><p> Write docs as code</p> <p>Let's focus our attention on creating good quality content and let the right tools let the hard work for us.</p> <p> Read more about this philosophy</p> </li> <li> <p></p><p> Work with Linux</p> <p>Linux ecosystem grants the freedom of open source, the opportunity for innovation, and the excitement of continuous learning.</p> <p> Get to know Pop!_Os</p> </li> <li> <p></p><p> Open source contributions</p> <p>Open source fosters collaborative innovation, and has the potential to enhance public administration efficiency.</p> <p> Read more about it</p> </li> <li> <p></p><p> Use Power Automate</p> <p>Power Automate empowers non-programmers to automate tasks, boost productivity, and innovate effortlessly.</p> <p> Get to know the Automatiza.MG project</p> </li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/python-pathlib/","title":"Python pathlib","text":""},{"location":"blog/python-pathlib/#python-pathlib","title":"Python pathlib","text":"<p>Working with files and interacting with the file system are common tasks for Python developers. That\u2019s where pathlib comes in. Let's understand how it works with the help of the Python's pathlib Module: Taming the File System post.</p> <ul> <li> <p>The pathlib module is part of Python\u2019s standard library.</p> </li> <li> <p>The pathlib\u2019s Path class works the same way on different operating systems.</p> </li> <li> <p>One motivation behind pathlib is to represent the file system with dedicated objects instead of strings<sup>1</sup>.</p> </li> <li> <p>Traditionally, Python has represented file paths using regular strings. However, paths are more than plain strings.</p> </li> <li> <p>As an initial example of pathlib usage, the following code block moves files into a subfolder:</p> <pre><code>from pathlib import Path # (1)!\n\nfor file_path in Path.cwd().glob(\"*.txt\"):\n    new_path = Path(\"archive\") / file_path.name # (2)!\n    file_path.replace(new_path)\n</code></pre> <ol> <li> <p> Because you\u2019ll mainly be working with the Path class of pathlib, importing it as <code>from pathlib import Path</code> saves you a few keystrokes in your code. This way, you can work with Path directly, rather than importing pathlib as a module and referring to <code>pathlib.Path</code>.</p> </li> <li> <p> The archive's folder must exists to ensure <code>.replace()</code> method works.</p> </li> </ol> </li> </ul>"},{"location":"blog/python-pathlib/#using-path-methods","title":"Using Path Methods","text":"<ul> <li> <p>Once you\u2019ve imported Path, you can make use of existing methods to get the current working directory (<code>cwd</code>) (1), or your user\u2019s home directory.</p> </li> <li> <p>To get your current working directory, you can use <code>.cwd()</code>:</p> </li> </ul> <ol> <li> The current working directory is the directory in the file system that the current process is operating in. Using the home directory as a starting point, you can specify paths that\u2019ll work on different machines, independent of any specific usernames.</li> </ol> LinuxmacOSWindows <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path.cwd() # (1)!\nPosixPath('/home/gabrielbdornas/Desktop/codei')\n</code></pre> <ol> <li> With <code>Path.cwd()</code>and <code>Path.home()</code>, you can conveniently get a starting point for your Python scripts. In cases where you need to spell paths out or reference a subdirectory structure, you can instantiate Path with a string.</li> </ol> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path.cwd() # (1)!\nPosixPath('/Users/gabrielbdornas/Desktop/codei')\n</code></pre> <ol> <li> With <code>Path.cwd()</code>and <code>Path.home()</code>, you can conveniently get a starting point for your Python scripts. In cases where you need to spell paths out or reference a subdirectory structure, you can instantiate Path with a string.</li> </ol> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path.cwd() # (1)!\nWindowsPath('C:/Users/gabrielbdornas/Desktop/codei')\n</code></pre> <ol> <li> With <code>Path.cwd()</code>and <code>Path.home()</code>, you can conveniently get a starting point for your Python scripts. In cases where you need to spell paths out or reference a subdirectory structure, you can instantiate Path with a string.</li> </ol> <ul> <li>To get your home directory, you can use <code>.home()</code>:</li> </ul> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path.home() # (1)!\nPosixPath('/home/gabrielbdornas/')\n</code></pre> <ol> <li> Using the home directory as a starting point, you can specify paths that\u2019ll work independent of any specific usernames.</li> </ol>"},{"location":"blog/python-pathlib/#passing-in-a-string","title":"Passing in a String","text":"<ul> <li>Instead of starting in your user\u2019s home directory or your current working directory, you can point to a directory or file directly by passing its string representation into Path:</li> </ul> LinuxWindows <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path(\"/home/gabrielbdornas/Desktop/codei/file.txt\")\nPosixPath('/home/gabrielbdornas/Desktop/codei/file.txt')\n</code></pre> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path(r\"C:\\Users\\gabrielbdornas\\codei\\file.txt\")\nWindowsPath('C:/Users/gabrielbdornas/Desktop/codei/file.txt') # (1)!\n</code></pre> <ol> <li> On Windows, the path separator is a backslash (). However, in many contexts, the backslash is also used as an escape character to represent non-printable characters. To avoid problems, use raw string literals to represent Windows paths like <code>r\"C:\\Users\"</code>.</li> </ol> The <code>__file__</code> attribute <p>An idiomatic way of working with the current module\u2019s location as the path is using <code>__file__</code>:</p> <pre><code># hello.py\n\nfrom pathlib import Path\n\nprint(f\"You can find me here: {Path(__file__).parent}!\") # (1)!\n</code></pre> <ol> <li> The <code>__file__</code> attribute contains the path to the file that Python is currently importing or executing. You can pass in <code>__file__</code> to Path when you need to work with the path to the module itself. For example, maybe you want to get the parent directory with <code>.parent</code>.</li> </ol>"},{"location":"blog/python-pathlib/#joining-paths","title":"Joining Paths","text":"<ul> <li>A third way to construct a path is to join the parts of the path using the special forward slash operator (<code>/</code>):</li> </ul> <pre><code>from pathlib import Path\n\nfor file_path in Path.cwd().glob(\"*.txt\"):\n    new_path = Path(\"archive\") / file_path.name # (1)!\n    file_path.rename(new_path)\n</code></pre> <ol> <li> The forward slash operator can join several paths or a mix of paths and strings as long as you include one Path object. You use a forward slash regardless of your platform\u2019s actual path separator.</li> </ol> The <code>.joinpath()</code> method <ul> <li>If you don\u2019t like the special slash notation, then you can do the same operation with the <code>.joinpath()</code> method:</li> </ul> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path.home().joinpath(\"python\", \"scripts\", \"test.py\")\nPosixPath('/home/gabrielbdornas/python/scripts/test.py')\n</code></pre>"},{"location":"blog/python-pathlib/#file-system-operations-with-paths","title":"File System Operations With Paths","text":"<ul> <li> <p>A file or directory path consists of different parts. When you use pathlib, these parts are conveniently available as properties. Basic examples include:</p> <ul> <li><code>.name</code>: The filename without any directory</li> <li><code>.stem</code>: The filename without the file extension</li> <li><code>.suffix</code>: The file extension</li> <li><code>.anchor</code>: The part of the path before the directories</li> <li><code>.parent</code>: The directory containing the file, or the parent directory if the path is a directory</li> </ul> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; path = Path(__file__)\n&gt;&gt;&gt; path\nPosixPath(\"/home/gabrielbdornas/codei/test.md\")\n\n&gt;&gt;&gt; path.name\n'test.md'\n\n&gt;&gt;&gt; path.stem\n'test'\n\n&gt;&gt;&gt; path.suffix\n'.md'\n\n&gt;&gt;&gt; path.anchor\n'/'\n\n&gt;&gt;&gt; path.parent # (1)!\nPosixPath(\"/home/gabrielbdornas/codei\")\n\n&gt;&gt;&gt; path.parent.parent\nPosixPath('/home/gabrielbdornas')\n</code></pre> <ol> <li> Note that <code>.parent</code> returns a new Path object, whereas the other properties return strings. This means, for instance, that you can chain <code>.parent</code> in the last example or even combine it with the slash operator to create completely new paths.</li> </ol> </li> </ul>"},{"location":"blog/python-pathlib/#reading-and-writing-files","title":"Reading and Writing Files","text":"<ul> <li>Consider that you want to print all the items on a shopping list that you wrote down in a Markdown file. The content of shopping_list.md looks like this:</li> </ul> <pre><code>&lt;!-- shopping_list.md --&gt;\n\n# Shopping List\n\n## Fruit\n\n* Banana\n* Apple\n* Peach\n\n## Candy\n\n* Chocolate\n* Nougat Bits\n</code></pre> <ul> <li> <p>With pathlib, you can use <code>open()</code> directly on Path objects.</p> </li> <li> <p>A first draft of your script that finds all the items in <code>shopping_list.md</code> and prints them may look like this:</p> <pre><code># read_shopping_list.py\n\nfrom pathlib import Path\n\npath = Path.cwd() / \"shopping_list.md\"\nwith path.open(mode=\"r\", encoding=\"utf-8\") as md_file: # (1)!\n    content = md_file.read()\n    groceries = [line for line in content.splitlines() if line.startswith(\"*\")]\nprint(\"\\n\".join(groceries))\n</code></pre> <ol> <li> In fact, <code>Path.open()</code> is calling the built-in <code>open()</code> function behind the scenes. That\u2019s why you can use parameters like mode and encoding with <code>Path.open()</code>.</li> </ol> </li> <li> <p>On top of that, pathlib offers some convenient methods to read and write files:</p> <ul> <li><code>.read_text()</code> opens the path in text mode and returns the contents as a string.</li> <li><code>.read_bytes()</code> opens the path in binary mode and returns the contents as a byte string.</li> <li><code>.write_text()</code> opens the path and writes string data to it<sup>2</sup><sup>3</sup>.</li> <li><code>.write_bytes()</code> opens the path in binary mode and writes data to it<sup>2</sup><sup>3</sup>.</li> </ul> </li> <li> <p>Therefore, you can update <code>read_shopping_list.py</code> using <code>.read_text()</code>:</p> <pre><code># read_shopping_list.py\n\nfrom pathlib import Path\n\npath = Path.cwd() / \"shopping_list.md\" # (1)!\ncontent = path.read_text(encoding=\"utf-8\")\ngroceries = [line for line in content.splitlines() if line.startswith(\"*\")]\nprint(\"\\n\".join(groceries))\n</code></pre> <ol> <li> You can also specify paths directly as in <code>Path(\"shopping_list.md\")</code>, in which case they\u2019re interpreted relative to the current working directory.</li> </ol> </li> <li> <p>If you want to create a plain shopping list that only contains the groceries, then you can use <code>.write_text()</code> in a similar fashion:</p> <pre><code># write_plain_shoppinglist.py\n\nfrom pathlib import Path\n\ncontent = Path(\"shopping_list.md\").read_text(encoding=\"utf-8\")\ngroceries = [line for line in content.splitlines() if line.startswith(\"*\")]\n\nPath(\"plain_list.md\").write_text(\"\\n\".join(groceries), encoding=\"utf-8\")\n</code></pre> </li> </ul>"},{"location":"blog/python-pathlib/#renaming-files","title":"Renaming Files","text":"<ul> <li> <p>When you want to rename files, you can use <code>.with_stem()</code>, <code>.with_suffix()</code>, or <code>.with_name()</code>. They return the original path but with the filename, the file extension, or both replaced. You can use all of them in combination with <code>.replace()</code>, example:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; txt_path = Path('/home/gabrielbdornas/codei/hello.txt')\n&gt;&gt;&gt; txt_path\nPosixPath('/home/gabrielbdornas/codei/hello.txt')\n\n&gt;&gt;&gt; md_path = txt_path.with_suffix('.md') # (1)!\nPosixPath('/home/gabrielbdornas/codei/hello.md')\n\n&gt;&gt;&gt; txt_path.replace(md_path) # (2)!\n</code></pre> <ol> <li> <p> Using <code>.with_suffix()</code> returns a new path.</p> </li> <li> <p> To actually rename the file, you use <code>.replace()</code>. This moves <code>txt_path</code> to <code>md_path</code> and renames it when saving.</p> </li> </ol> </li> <li> <p>If you want to change the complete filename, including the extension, then you can use <code>.with_name()</code>:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; txt_path = Path('/home/gabrielbdornas/codei/hello.txt')\n&gt;&gt;&gt; txt_path\nPosixPath('/home/gabrielbdornas/codei/hello.txt')\n\n&gt;&gt;&gt; md_path = txt_path.with_name('goodbye.md')\nPosixPath('/home/gabrielbdornas/codei/goodbye.md')\n\n&gt;&gt;&gt; txt_path.replace(md_path) # (1)!\n</code></pre> <ol> <li> It renames <code>hello.txt</code> to <code>goodbye.md</code>.</li> </ol> </li> </ul>"},{"location":"blog/python-pathlib/#copying-files","title":"Copying Files","text":"<ul> <li> <p>Surprisingly, Path doesn\u2019t have a method to copy files. But with the knowledge that you\u2019ve gained about pathlib so far, you can create the same functionality with a few lines of code:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; source = Path('shopping_list.md')\n&gt;&gt;&gt; destination = source.with_stem('shopping_list_02') # (1)!\n&gt;&gt;&gt; destination.write_bytes(source.read_bytes()) # (2)!\n</code></pre> <ol> <li> You\u2019re using <code>.with_stem()</code> to create the new filename without changing the extension.</li> <li> The actual copying takes place here, where you use <code>.read_bytes()</code> to read the content of source and then write this content to destination using <code>.write_bytes()</code>.</li> </ol> </li> </ul>"},{"location":"blog/python-pathlib/#moving-and-deleting-files","title":"Moving and Deleting Files","text":"<ul> <li> <p>Through pathlib, you also have access to basic file system\u2013level operations like moving, updating, and even deleting files. For the most part, these methods don\u2019t give a warning or wait for confirmation before getting rid of information or files. So, be careful when using these methods<sup>3</sup>.</p> </li> <li> <p>To move a file, you can use <code>.replace()</code><sup>2</sup>. To avoid possibly overwriting the destination path, you can test whether the destination exists before replacing:</p> <pre><code>from pathlib import Path\nsource = Path('hello.py')\ndestination = Path('goodbye.py')\n\nif not destination.exists():\n  source.replace(destination)\n</code></pre> </li> <li> <p>However, this does leave the door open for a possible race condition. Another process may add a file at the destination path between the execution of the if statement and the <code>.replace()</code> method. If that\u2019s a concern, then a safer way is to open the destination path for exclusive creation then explicitly copy the source data and delete the source file afterward:</p> <pre><code>from pathlib import Path\n\nsource = Path('hello.py')\ndestination = Path('goodbye.py')\n\ntry:\n  with destination.open(mode='xb') as file:\n    file.write(source.read_bytes())\nexcept FileExistsError:\n    print(f'File {destination} existis already') # (1)!\nelse:\n    source.unlink() # (2)!\n</code></pre> <ol> <li> <p> If destination already exists, it catches a <code>FileExistsError</code> and prints a warning message.</p> </li> <li> <p> To perform a move, you need to delete source with <code>.unlink()</code> after the copy is done. Using <code>else</code> ensures that the source file isn\u2019t deleted if the copying fails.</p> </li> </ol> </li> </ul>"},{"location":"blog/python-pathlib/#creating-empty-files","title":"Creating Empty Files","text":"<ul> <li> <p>To create an empty file with pathlib, you can use <code>.touch()</code>. This method is intended to update a file\u2019s modification time, but you can use its side effect to create a new file:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; filename = Path('hello.py')\n&gt;&gt;&gt; filename.exists()\nFalse\n\n&gt;&gt;&gt; filename.touch()\n&gt;&gt;&gt; filename.exists() # (1)!\nTrue\n\n&gt;&gt;&gt; filename.touch() # (2)!\n</code></pre> <ol> <li> <p> You use <code>.exists()</code> both to verify that the file didn\u2019t exist before and then to check that it was successfully created.</p> </li> <li> <p> If you use <code>.touch()</code> again, then it updates the file\u2019s modification time. If you don\u2019t want to modify files accidentally, then you can use the <code>exist_ok</code> parameter and set it to False as in <code>filename.touch(exist_ok=False)</code>.</p> </li> </ol> </li> </ul>"},{"location":"blog/python-pathlib/#python-pathlib-examples","title":"Python pathlib Examples","text":""},{"location":"blog/python-pathlib/#counting-files","title":"Counting Files","text":"<ul> <li> <p>With pathlib, you can conveniently use the <code>.iterdir()</code> method, which iterates over all the files in the given directory:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; counter(path.suffix for path in Path.cwd().iterdir()) # (1)!\nCounter({'.md': 2, '.txt': 4, '.pdf': 2, '.py': 1})\n</code></pre> <ol> <li> You can create more flexible file listings with the methods <code>.glob()</code> and <code>.rglob()</code>. For example, <code>Path.cwd().glob(\"*.txt\")</code> returns all the files with a <code>.txt</code> suffix in the current directory. If you want to recursively find all the files in both the directory and its subdirectories, then you can use <code>.rglob()</code>.</li> </ol> </li> </ul>"},{"location":"blog/python-pathlib/#displaying-a-directory-tree","title":"Displaying a Directory Tree","text":"<ul> <li>In this example, you define a function named <code>tree()</code>, which will print a visual tree representing the file hierarchy, rooted at a given directory. This is useful when, for example, you want to peek into the subdirectories of a project.</li> </ul> <pre><code># display_dir_tree.py\n\ndef tree(directory):\n    print(f\"+ {directory}\")\n    for path in sorted(directory.rglob(\"*\")):\n        depth = len(path.relative_to(directory).parts) # (1)!\n        spacer = \"    \" * depth\n        print(f\"{spacer}+ {path.name}\")\n</code></pre> <ol> <li> <p> Note that you need to know how far away from the root directory a file is located. To do this, you first use <code>.relative_to()</code> to represent a path relative to the root directory. Then, you use the <code>.parts</code> property to count the number of directories in the representation.</p> </li> <li> <p>When run, this function creates a visual tree like the following:</p> </li> </ol> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from display_dir_tree import tree\n&gt;&gt;&gt; tree(Path.cwd())\n+ /home/gabrielbdornas/codei\n    + directory_1\n        + file_a.md\n    + directory_2\n        + file_a.md\n        + file_b.pdf\n        + file_c.py\n    + file_1.txt\n    + file_2.txt\n</code></pre>"},{"location":"blog/python-pathlib/#finding-the-most-recently-modified-file","title":"Finding the Most Recently Modified File","text":"<ul> <li>The <code>.iterdir()</code>, <code>.glob()</code>, and <code>.rglob()</code> methods are great fits for generator expressions and list comprehensions.To find the most recently modified file in a directory, you can use the <code>.stat()</code> method to get information about the underlying files. For instance, <code>.stat().st_mtime</code> gives the time of last modification of a file:</li> </ul> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; directory = Path.cwd()\n&gt;&gt;&gt; time, file_path = max((f.stat().st_mtime, f) for f in directory.iterdir())\n&gt;&gt;&gt; print (datetime.fromtimestamp(time), file_path)\n2024-06-18 11:23:56.977817 /home/gabrielbdornas/codei/test001.txt\n</code></pre>"},{"location":"blog/python-pathlib/#creating-a-unique-filename","title":"Creating a Unique Filename","text":"<ul> <li>In the last example, you\u2019ll construct a unique numbered filename based on a template string. This can be handy when you don\u2019t want to overwrite an existing file if it already exists:</li> </ul> <pre><code># unique_path.py\n\ndef unique_path(directory, name_pattern): # (1)!\n  counter = 0\n  while True:\n    counter += 1\n    path = directory / name_pattern.format(counter)\n    if not path.exists():\n      return path\n</code></pre> <ol> <li> <p> In <code>unique_path()</code>, you specify a pattern for the filename, with room for a counter. Then, you check the existence of the file path created by joining a directory and the filename, including a value for the counter. If it already exists, then you increase the counter and try again.</p> </li> <li> <p>Now you can use the script above to get unique filenames:</p> </li> </ol> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from unique_path import unique_path\n&gt;&gt;&gt; template = \"test{:03d}.txt\"\n&gt;&gt;&gt; unique_path(Path.cwd(), template)\nPosixPath(\"/home/gabrielbdornas/codei/test003.txt\") # (1)!\n</code></pre> <ol> <li> If the directory already contains the files <code>test001.txt</code> and <code>test002.txt</code>, then the above code will set path to <code>test003.txt</code>.</li> </ol>"},{"location":"blog/python-pathlib/#conclusion","title":"Conclusion","text":"<ul> <li> <p>Python\u2019s pathlib module provides a modern and Pythonic way of working with file paths, making code more readable and maintainable. With pathlib, you can represent file paths with dedicated Path objects instead of plain strings<sup>1</sup>.</p> </li> <li> <p>The pathlib module makes dealing with file paths convenient by providing helpful methods and properties. Peculiarities of the different systems are hidden by the Path object, which makes your code more consistent across operating systems.</p> </li> </ul> <ol> <li> <p>In general, you should try to use Path objects as much as possible in your code to take advantage of their benefits, but converting them to strings can be necessary in certain contexts. Some libraries and APIs still expect you to pass file paths as strings, so you may need to convert a Path object to a string before passing it to certain functions. You'll see that, on Windows, although you enter paths with backslashes, pathlib represents them with the forward slash (/) as the path separator. This representation is named POSIX style. POSIX stands for Portable Operating System Interface, which is a standard for maintaining the compability between operating systems.\u00a0\u21a9\u21a9</p> </li> <li> <p>When using these methods, Python overwrites any existing files on the same path without giving you any notice. That means you could erase all your hard work with a single keystroke! As always, when you write files with Python, you should be cautious of what your code is doing. The same is true when you\u2019re renaming files.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>A good way to protect yoursef of this kind of troble is using version control system while writing your codes.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"blog/running-linux-on-windows-with-wsl-a-guide-for-developers-and-non-developers/","title":"Running Linux on Windows with WSL: A guide for developers and non-developers","text":""},{"location":"blog/running-linux-on-windows-with-wsl-a-guide-for-developers-and-non-developers/#running-linux-on-windows-with-wsl-a-guide-for-developers-and-non-developers","title":"Running Linux on Windows with WSL: A guide for developers and non-developers","text":"<p>If you've ever wanted to use Linux commands within your Windows environment, the Windows Subsystem for Linux (WSL) is an excellent tool by Microsoft. It allows you to run Linux distributions on Windows, primarily through the command line, but also supports some graphical applications.</p> <p>As a Linux user, my search for this WSL solution began after a frustrating experience with Windows tools like Git Bash, which felt clunky and limited in comparison.</p> <p>As you'll see, installing WSL alongside with Oh My Zsh terminal, transforms the Windows terminal into a far more powerful and visually appealing environment, similar to what I was used to on Linux.</p> <p>For non-technical users, WSL offers a gentle introduction to Linux, letting you explore this powerful operating system without fully switching away from Windows. With WSL, you can try out new tools and commands that can simplify tasks and boost productivity, especially useful if you're curious about Linux or have heard about its efficiency for certain tasks.</p> <p>The setup I present here, allows you to gradually get comfortable with a Linux environment, learn at your own pace, and see the benefits firsthand, all within the familiarity of your Windows system.</p> <p>I\u2019m confident that once you experience the flexibility and ease of using Linux tools within Windows through WSL, you might just find yourself wondering how you ever worked without it!</p>"},{"location":"blog/running-linux-on-windows-with-wsl-a-guide-for-developers-and-non-developers/#what-is-wsl","title":"What is WSL?","text":"<p>First things first. What is WSL? It's a tool that enables Linux to run directly within Windows, which is helpful for software development, system administration, or just exploring Linux tools without leaving Windows. Originally introduced as WSL1, WSL2 is an improved version that offers more robust performance and a real Linux kernel for enhanced compatibility.</p>"},{"location":"blog/running-linux-on-windows-with-wsl-a-guide-for-developers-and-non-developers/#key-benefits-of-wsl","title":"Key benefits of WSL","text":"<ol> <li> <p>Low resource usage: Unlike full virtualization software like VirtualBox or VMware, WSL uses fewer resources, making it ideal for quickly accessing Linux tools without heavy memory or CPU demands.</p> </li> <li> <p>Developer-focused but broadly useful: While it\u2019s popular with developers, WSL offers useful tools for non-programmers as well, making it a versatile solution for anyone who wants to use Linux utilities within Windows.</p> </li> <li> <p>Integration with Windows: You can access Windows file systems directly from within Linux and vice versa, creating a seamless experience for file management across both environments.</p> </li> </ol>"},{"location":"blog/running-linux-on-windows-with-wsl-a-guide-for-developers-and-non-developers/#wsl-usage-prerequisites","title":"WSL usage prerequisites:","text":"<p>To install the Windows Subsystem for Linux (WSL), your machine needs to meet the following prerequisites:</p> <ol> <li> <p>Operating System:</p> <ul> <li>Windows 10 (Version 2004 and higher, with Build 19041 and higher).</li> <li>Windows 11 (any version).</li> </ul> Tip <p>To check your Windows version and build number press <code>Win + R</code> to open the Run dialog, type <code>winver</code>, and press Enter.</p> </li> <li> <p>System Requirements:</p> <ul> <li>64-bit Processor: WSL2 requires a 64-bit processor. Older 32-bit versions of Windows cannot run WSL2.</li> <li>Virtualization Support: Your system must support virtualization. This is typically available on most modern CPUs, but make sure it\u2019s enabled in the BIOS/UEFI 'settings.</li> </ul> Tip <p>Ensure that virtualization is enabled in your BIOS or UEFI settings. This is often labeled as Intel VT-x (for Intel processors) or AMD-V (for AMD processors).</p> </li> <li> <p>Windows Update: Make sure your system is up-to-date with the latest Windows updates. WSL2 requires specific updates that are available in the latest versions of Windows 10 and 11.</p> </li> </ol> <p>Once you have verified these prerequisites, you can proceed with the installation.</p>"},{"location":"blog/running-linux-on-windows-with-wsl-a-guide-for-developers-and-non-developers/#windows-11-wsl-installation","title":"Windows 11 WSL installation","text":"<p>To enable WSL on Windows 11:</p> Info <p>If you're using Windows 10, the installation process is a bit different. A quick online search should guide you through it, but if you need any extra help, feel free to ask in the comments below.</p> <ol> <li>Open PowerShell as Administrator.</li> <li> <p>Run the following command:</p> <pre><code>wsl --install # (1)!\n</code></pre> <ol> <li> This command installs WSL, sets WSL2 as the default version, and installs Ubuntu as the default Linux distribution. After the installation, you may need to restart your computer. To install other Linux distributions, use the command <code>wsl --install -d &lt;distribution-name&gt;</code>. You can view available distribution options by running <code>wsl --list --online</code>. For a full list of <code>wsl</code> command options, use the <code>--help</code> flag. For example, you can check the status and list all installed WSL distributions by using <code>wsl --list --verbose</code>.</li> </ol> Tip <p>Install Windows Terminal    through Microsoft Store to streamline your WSL experience.</p> </li> <li> <p>After installation, you can launch WSL by searching for \"WSL\" or \"Ubuntu\" in the Start Menu .</p> </li> <li> <p>When you open WSL for the first time, you'll be prompted to create a Linux username and password for administrative tasks.</p> Tip <p> When you're prompted to enter your password, you won\u2019t see any characters appear on the screen as you type. Don't worry, this is normal and a security feature. Just type your password carefully and press Enter.</p> </li> </ol>"},{"location":"blog/running-linux-on-windows-with-wsl-a-guide-for-developers-and-non-developers/#accessing-files-and-running-linux-applications","title":"Accessing files and running linux applications","text":"<p>One unique feature of WSL is the ability to interact with files across both Windows and Linux environments.</p> <p>For instance:</p> <ul> <li>Windows directories are accessible from Linux via <code>/mnt/c</code>.</li> <li> <p>You can open Linux files directly in Windows Explorer by typing <code>\\\\wsl$\\Ubuntu</code> (1) in the address bar.</p> <ol> <li> Replace <code>Ubuntu</code> in case your linux distribution is different.</li> </ol> </li> </ul>"},{"location":"blog/running-linux-on-windows-with-wsl-a-guide-for-developers-and-non-developers/#example-running-a-simple-web-server","title":"Example: running a simple web server","text":"<p>A quick example of how WSL can be used effectively is running a web server:</p> <ol> <li>In WSL, navigate to the directory where you want to serve files.</li> <li> <p>Run a simple Python HTTP server:</p> <pre><code>python3 -m http.server 8000\n</code></pre> </li> <li> <p>Access this server in a Windows browser by going to <code>http://localhost:8000</code>.</p> </li> </ol>"},{"location":"blog/running-linux-on-windows-with-wsl-a-guide-for-developers-and-non-developers/#using-a-fancier-terminal","title":"Using a Fancier Terminal","text":"<p>To enhance our user experience, let's chance the Ubuntu's default terminal to Oh My Zsh. Installing Zsh with Oh My Zsh on WSL create a powerful and visually appealing environment that closely mirrors the efficiency of Linux.</p> <p>It introduces features like auto-suggestions, syntax highlighting, and easy customization, making command-line tasks smoother and more intuitive.</p> <p>This strategy not only enhances the terminal\u2019s appearance but also delivers a truly efficient, Linux-like command-line experience for Windows users.</p> <ol> <li> <p>Open your WSL terminal and run the commands below to install Zsh:</p> <pre><code>sudo apt update # (1)!\nsudo apt install zsh -y\nchsh -s $(which zsh) # (2)!\n</code></pre> <ol> <li> Run one command at the time.</li> <li> You may need to log out and log back in to see the change, or simply open a new WSL terminal window to start using Zsh.</li> </ol> </li> <li> <p>Install Oh My Zsh:</p> </li> </ol> <p>Oh My Zsh is a framework for managing Zsh configurations, and it comes with themes and plugins that make your terminal experience more powerful and customizable.</p> <p>We'll cover just the basics here, but it\u2019s exactly what we need to get started.To install it, use this command:</p> <pre><code>sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n</code></pre> <p>Give Zsh and Oh My Zsh a try on WSL, and let me know in the comments below if you enjoy the more visually appealing and productive terminal experience!</p>"},{"location":"blog/running-linux-on-windows-with-wsl-a-guide-for-developers-and-non-developers/#final-thoughts","title":"Final Thoughts","text":"<p>WSL bridges the gap between Windows and Linux, creating a streamlined workflow for development and general Linux usage within Windows. This integration not only serves technical needs but is also an excellent entry point for those new to Linux.</p> <p>For newcomers, WSL offers a way to explore Linux tools and get accustomed to the Linux terminal without committing to a full operating system switch. This means you can experiment without reconfiguring your entire setup, making it easy to see if Linux aligns with your expectation and workflows.</p> <p>For technical users, WSL resolves some familiar frustrations, like line-ending compatibility issues between Windows and Linux. By writing and running code in a Linux environment, you avoid these interruptions, improving the consistency of your development process.</p> <p>Additionally, WSL provides a more robust terminal experience than options like Git Bash, CMD, or PowerShell, which often fall short in user experience, at least in my opinion. With WSL, you gain access to a more native Linux terminal, offering improved tool support and a smoother, more powerful command-line interface.</p> <p>Whether you're a developer or just curious, WSL presents a flexible, efficient gateway to Linux that can significantly enhance your productivity and comfort in either system.</p> Get in touch <p>I worked hard to ensure that all the content in this post is accurate and error-free. However, I know that mistakes can happen, as I'm only human! If you find any, or if you have questions or suggestions, please don\u2019t hesitate to reach out in the comment section below.</p> <p>If you prefer, send an email to gabrielbdornas@gmail.com.</p>"},{"location":"blog/running-linux-on-windows-with-wsl-a-guide-for-developers-and-non-developers/#references","title":"References","text":"<ul> <li>One of the BEST things Microsoft has ever done - How to use WSL (Linux within Windows).</li> <li>How to install Linux on Windows with WSL.</li> <li>Frequently Asked Questions about Windows Subsystem for Linux.</li> </ul>"},{"location":"overrides/partials/blog/found_error/","title":"Found error","text":"Get in touch <p>I worked hard to ensure that all the content in this post is accurate and error-free. However, I know that mistakes can happen, as I'm only human! If you find any, or if you have questions or suggestions, please don\u2019t hesitate to reach out in the comment section below.</p> <p>If you prefer, send an email to gabrielbdornas@gmail.com.</p>"},{"location":"blog/category/linux/","title":"Linux","text":""},{"location":"blog/category/windows/","title":"Windows","text":""},{"location":"blog/category/python/","title":"Python","text":""},{"location":"blog/category/pythons-standard-library/","title":"Python\u2019s standard library","text":""}]}